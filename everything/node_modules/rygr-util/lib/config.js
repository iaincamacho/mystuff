var attributes, deepFreeze, fs, glob, initialize, parseAttributes, path, queryAndReadFiles, readFiles, _;

_ = require('underscore');

glob = require('glob');

path = require('path');

fs = require('fs');

_.mixin({
  deepExtend: require('underscore-deep-extend')(_)
});

initialize = function(queries, options) {
  var configs, defaults, errors, files, _ref;
  if (options == null) {
    options = {};
  }
  if (!(_.isArray(queries) || _.isString(queries))) {
    throw new Error('Config queries must be a string or array');
  }
  defaults = {
    env: process.env.NODE_ENV || 'development',
    freeze: true,
    cwd: process.cwd(),
    root: path.resolve(options.cwd, '/'),
    inMemory: true
  };
  _.defaults(options, defaults);
  if (options.debug == null) {
    options.debug = options.env === 'development' ? true : false;
  }
  _ref = queryAndReadFiles(queries, options), errors = _ref[0], files = _ref[1];
  if (errors && options.debug) {
    console.error.apply(console, errors);
  }
  if (options.inMemory) {
    delete attributes.initialize;
    files = [attributes].concat(files);
  }
  configs = _.deepExtend.apply(_, files);
  if (!((options.deepFreeze != null) && !options.deepFreeze)) {
    deepFreeze(configs);
  }
  return configs;
};

queryAndReadFiles = function(queries, options) {
  var configs, e, errors, fileErrors, filenames, files, query, _i, _len, _ref;
  errors = [];
  configs = [];
  if (_.isString(queries)) {
    queries = [queries];
  }
  for (_i = 0, _len = queries.length; _i < _len; _i++) {
    query = queries[_i];
    try {
      filenames = glob.sync(query, _.pick(options, 'root', 'cwd'));
    } catch (_error) {
      e = _error;
      errors.push(e);
      continue;
    }
    _ref = readFiles(filenames, options), fileErrors = _ref[0], files = _ref[1];
    if (fileErrors) {
      errors = errors.concat(fileErrors);
    }
    configs.push(files);
  }
  if (errors.length) {
    return [errors, configs];
  } else {
    return [null, configs];
  }
};

readFiles = function(filenames, options) {
  var e, errors, file, filename, files, fullPath, key, _i, _len;
  files = {};
  errors = [];
  for (_i = 0, _len = filenames.length; _i < _len; _i++) {
    filename = filenames[_i];
    fullPath = path.resolve(filename);
    try {
      file = require(fullPath);
    } catch (_error) {
      e = _error;
      errors.push(e);
      continue;
    }
    if (!_.isObject(file)) {
      errors.push(new Error("File <" + fullPath + "> is not an object"));
      continue;
    }
    key = path.basename(filename, path.extname(filename));
    files[key] = parseAttributes(file, options.env);
  }
  if (errors.length) {
    return [errors, files];
  } else {
    return [null, files];
  }
};

parseAttributes = function(data, env) {
  var options, _ref;
  if (options = (_ref = data.environments) != null ? _ref[env] : void 0) {
    _.extend(data, options);
  }
  delete data.environments;
  return data;
};

deepFreeze = function(object) {
  var key, property, value, _results;
  Object.freeze(object);
  _results = [];
  for (key in object) {
    value = object[key];
    property = object[key];
    if (object.hasOwnProperty(property) && _.isObject(property) && !Object.isFrozen(property)) {
      _results.push(deepFreeze(property));
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

attributes = {
  initialize: initialize
};

module.exports = attributes;
